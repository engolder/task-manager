# Claude Code 작업 가이드

## ⚠️ 중요 - Git 작업 시 필수 준수사항 ⚠️
**모든 커밋과 PR에서 다음 문구들은 절대 사용 금지:**
- ❌ `"🤖 Generated with [Claude Code](https://claude.ai/code)"`
- ❌ `"Co-Authored-By: Claude <noreply@anthropic.com>"`
- ❌ 기타 Claude 관련 메타 정보

**항상 개발자가 직접 작성한 것처럼 자연스럽고 깔끔하게 작성**

---

## 1. Claude Code 기본 동작 원칙

### 1.1 기본 워크플로우
- Claude Code의 기본적인 작업 방식을 유지
- 사용자 요청을 직접적이고 효율적으로 처리
- TaskWrite 도구를 활용한 체계적 작업 관리

### 1.2 작업 진행 방식
- 사용자 요청 즉시 분석 및 작업 시작
- 복잡한 작업의 경우 TaskWrite로 단계별 계획 수립
- 각 단계 완료 시 진행 상황 업데이트

### 1.3 워크로그 참조 및 활용
- **작업 시작 전 워크로그 검토**: 관련 작업이 이전에 수행된 적이 있는지 `worklogs/` 디렉토리 확인
- **컨텍스트 파악**: 기존 워크로그에서 유사한 작업의 접근 방법, 문제점, 해결책 참조
- **일관성 유지**: 이전 작업의 패턴과 결정사항을 고려하여 일관된 접근 방식 적용
- **경험 활용**: 과거의 실패 사례나 성공 사례를 바탕으로 더 효율적인 작업 진행
- **작업 완료 후**: 새로운 워크로그 생성 또는 기존 워크로그 업데이트로 지식 축적

## 2. Plan Mode 작성 가이드

### 2.1 계획서 깊이 결정
계획의 복잡도는 작업의 영향 범위에 따라 조정:

**심층 분석이 필요한 경우:**
- 여러 파일/모듈에 걸친 구조적 변경
- 기존 패턴의 마이그레이션 또는 리팩토링
- 여러 구현 방식 중 선택이 필요한 경우
- 플랫폼/환경별로 다른 접근이 필요한 경우
- 아키텍처 결정이나 기술 스택 변경

**간단한 계획으로 충분한 경우:**
- 단일 파일/함수의 변경
- 명확한 요구사항의 기능 추가
- 문서화 작업
- 명백한 버그 수정

### 2.2 심층 계획서 구조

복잡한 작업의 경우 다음 구조를 권장:

#### 1) Current State (현재 상태 분석)
- 관련된 모든 구현체/파일 조사
- 각 구현의 상태를 시각적으로 표시
  - ✅ 이미 요구사항 충족
  - ❌ 변경 필요
  - ⚠️ 부분적으로 문제 있음
- 코드 예시와 위치 명시 (file_path:line_number)

#### 2) Problem (문제 정의)
- 왜 변경이 필요한가
- 현재 접근 방식의 한계
- 기술적 제약사항
- 해결하지 않을 경우의 영향

#### 3) Solution Plan (해결 방안)
- 여러 옵션이 있다면 모두 나열
- 각 옵션의 장단점 비교
- 선택한 방안과 그 이유
- 단계별 접근 방법
- 예상되는 리스크와 대응 방안

#### 4) Files to Modify (변경 대상)
- 수정할 파일 목록
- 각 파일에서 수행할 구체적 작업
- 파일 간 의존성이 있다면 순서 명시
- 테스트 파일이나 문서 업데이트도 포함

### 2.3 계획서 작성 예시

```
API 인증 방식 마이그레이션 분석

Current State

프로젝트 전반에 걸쳐 다양한 인증 방식이 혼재:

1. frontend/src/api/userAPI.ts:45
  - fetch() with Authorization header
  ✅ 이미 토큰 기반 인증 사용

2. frontend/src/api/adminAPI.ts:23
  - axios with interceptor
  ✅ 이미 토큰 기반 인증 사용

3. backend/src/auth/middleware.ts:67
  - JWT 토큰 검증 로직
  ✅ 표준 방식 구현됨

4. legacy/src/api/client.js:12
  ❌ 마이그레이션 필요:
  - 세션 기반 쿠키 인증 사용
  - 만료 처리 로직 없음

5. mobile/src/services/api.ts:89
  ⚠️ 부분적으로 문제:
  - 토큰 사용하지만 리프레시 로직 누락
  - 만료 시 자동 재로그인 필요

Problem

레거시 코드와 모바일 앱의 인증 방식 문제:
- 세션 기반 인증은 확장성 제한 (로드밸런싱 어려움)
- 토큰 만료 처리가 일관되지 않음
- 사용자 경험 저하 (갑작스런 로그아웃)
- 보안 위험 (만료된 토큰 재사용 가능성)

Solution Plan

1. 레거시 코드 마이그레이션
   세션 기반 인증을 JWT 토큰 방식으로 전환

2. 토큰 리프레시 전략 선택

   Option A: Sliding Window 방식
   + 구현 간단
   + 서버 부하 적음
   - 장기 미사용 시 재로그인 필요

   Option B: Refresh Token 방식
   + 더 나은 사용자 경험
   + 세밀한 권한 제어 가능
   - 구현 복잡도 증가
   - 추가 저장소 필요

   → Option B 선택: 사용자 경험이 우선순위

3. 일관된 인증 클라이언트 구현
   - 공통 인터셉터로 토큰 갱신 로직 중앙화
   - 실패 시 자동 재시도 메커니즘

4. 단계적 롤아웃
   - Phase 1: 백엔드 리프레시 엔드포인트 추가
   - Phase 2: 프론트엔드/모바일 클라이언트 업데이트
   - Phase 3: 레거시 세션 인증 제거

Files to Modify

1. backend/src/auth/token.service.ts
   - generateRefreshToken() 메서드 추가
   - refreshAccessToken() 엔드포인트 구현

2. backend/src/auth/middleware.ts
   - 리프레시 토큰 검증 로직 추가

3. frontend/src/api/client.ts (신규)
   - 통합 API 클라이언트 생성
   - 자동 토큰 갱신 인터셉터 구현

4. legacy/src/api/client.js
   - 세션 기반 인증 제거
   - 새로운 토큰 기반 클라이언트로 교체

5. mobile/src/services/api.ts
   - 리프레시 로직 추가
   - 공통 클라이언트와 동일한 패턴 적용

6. backend/src/database/migrations/
   - refresh_tokens 테이블 생성 마이그레이션
```

## 3. 개발 도구 및 명령어

### 3.1 Git 및 PR 관리
**Git 작업 및 PR 생성은 `/pr-open` 명령어를 사용하세요.**
- 자동으로 Git 상태 확인 및 커밋 생성
- PR 본문 자동 작성 및 사용자 승인 프로세스
- 상세한 가이드라인: `.claude/commands/pr-open.md` 참조

### 3.2 가이드라인 동기화
**코드 변경사항을 CLAUDE.md 파일에 자동 반영하려면 `/guide-sync` 명령어를 사용하세요.**
- Git 변경사항을 자동 분석하여 해당하는 CLAUDE.md 파일 업데이트
- 아키텍처 변경, 새로운 기술 스택, API 변경 등 중요한 변경사항을 문서화
- Frontend/Backend/공통 영역별로 적절한 가이드라인 파일에 자동 매핑
- 상세한 가이드라인: `.claude/commands/guide-sync.md` 참조

## 4. 품질 관리

### 4.1 코드 수정 원칙
- **최소 변경 원칙 준수**
  - 요청된 변경사항에만 집중
  - 불필요한 코드 재작성 지양
  - 기존 코드의 의도와 맥락 유지

- **변경 범위 명확화**
  - 수정이 필요한 부분을 명확히 식별
  - 연관된 부분에 미치는 영향 검토
  - 의도하지 않은 변경사항 방지

### 4.2 코드 리뷰 체크리스트
변경사항 적용 전 다음 사항 확인:
- [ ] 요청된 변경사항만 포함되었는가?
- [ ] 기존 기능이 그대로 유지되는가?
- [ ] UI/스타일링이 의도치 않게 변경되지 않았는가?
- [ ] 연관된 테스트가 모두 통과하는가?
- [ ] 성능에 부정적 영향을 주지 않는가?

## 5. 문제 해결 및 커뮤니케이션

### 5.1 문제 해결 원칙
- 오류 상황 명확히 파악하고 원인 분석
- 해결 방안의 영향도 평가 후 사용자에게 제시
- 환경 설정 문제는 영구적 해결 방안 우선 제시

### 5.2 커뮤니케이션 원칙
- 명확하고 구조화된 형식으로 보고
- 전문 용어 사용 시 설명 추가
- 대안이 있는 경우 장단점과 함께 제시
- 기술적 제안 시 근거와 예상 효과 제시

## 6. 정보 정확성 관리

### 6.1 정보 출저 우선순위
1. 공식 문서 (최신 버전)
2. 프레임워크/라이브러리의 공식 블로그나 릴리즈 노트
3. 프로젝트 내부 문서 (워크로그 등)
4. 커뮤니티 문서나 블로그 포스트

### 6.2 버전 관리
- 모든 기술 문서 참조 시 반드시 버전 정보 확인
- 프로젝트에서 사용 중인 버전과 문서의 버전이 일치하는지 검증
- 버전 차이가 있는 경우 반드시 사용자에게 고지

## 7. 코드와 룰의 동기화

### 7.1 코드 변경에 따른 룰 업데이트
- 코드베이스가 변경될 때 관련 룰도 함께 업데이트
- 더 이상 유효하지 않은 예시나 설명 제거
- 새로운 코드 패턴이나 구조를 반영하여 룰 수정

### 7.2 업데이트 프로세스
- 코드 변경 시 관련 룰 파일 검토
- 룰의 예시 코드가 최신 코드베이스와 일치하는지 확인
- 필요한 경우 새로운 예시 추가 또는 기존 예시 수정
- 변경된 코드 구조나 패턴을 룰에 반영

### 7.3 동기화 검증
- 정기적으로 룰의 예시와 실제 코드베이스 비교
- 더 이상 사용되지 않는 패턴이나 구조 식별
- 새롭게 도입된 패턴이나 구조가 룰에 반영되었는지 확인

# important-instruction-reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.