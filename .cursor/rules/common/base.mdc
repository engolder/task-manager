
# 에이전트 작업 처리 프로세스

## 1. 작업 요청 접수 및 분석

### 1.1 요구사항 분석
- 사용자의 요청을 명확하게 이해하고 재정리
- 모호한 부분이나 기술적 선택이 필요한 경우 즉시 사용자에게 질의
  - 예: "Foo 라이브러리의 Bar 함수를 사용하면 성능상 이점이 있을 것 같은데, 이 방향으로 진행해도 될까요?"
- 작업의 목적과 기대효과 명시

### 1.2 기술 명세 작성 및 공유
작업 시작 전 반드시 `worklogs/[주제].md` 파일을 생성하여 사용자와 공유. 다음 형식을 기본으로 하되 작업 특성에 맞게 필요한 섹션을 추가하거나 제외:

#### 워크로그 파일 구조
```
worklogs/
├── capacitor.md     # iOS/Android 앱 래핑 관련 작업
├── auth.md         # 인증/인가 관련 작업
├── database.md     # 데이터베이스 관련 작업
└── deployment.md   # 배포 관련 작업
```

#### 워크로그 파일 명명 규칙
- 의미있는 주제 이름 사용
- 모두 소문자로 작성
- 하이픈(-) 사용 가능
- 예시:
  - `capacitor.md`
  - `oauth-setup.md`
  - `database-migration.md`

#### 워크로그 템플릿
```markdown
## 1. 요구사항 분석 및 기술 명세

### 1.1 요구사항 정리
- 사용자가 요청한 작업 내용을 명확하게 재정리
- 요구사항의 목적과 기대효과
- 제약사항이나 고려사항

### 1.2 기술 명세
- 수정이 필요한 파일 목록과 구체적인 변경 내용
- 필요한 의존성이나 환경 요구사항
- 구현 방식과 아키텍처 설계

### 1.3 작업 순서 및 진행 상황
각 작업 단계별로 다음 정보를 포함하여 실시간으로 업데이트:

1. 작업 단계 1 [상태 이모지]
   - 세부 작업 항목
     ```bash
     # 실행한 명령어
     command arg1 arg2
     ```
   - 발견된 이슈들:
     1. 이슈 설명
        - 원인
        - 해결 방법
   - 해결된 사항:
     1. 완료된 작업 설명
        - 구체적인 변경 내용
        - 적용된 해결책

[상태 이모지 가이드]
✅ - 완료된 작업
⚠️ - 진행 중이며 이슈가 있는 작업
🔄 - 대기 중인 작업
❌ - 실패한 작업/차단된 작업

### 1.4 고려가 필요한 점
- 추가 작업이 예상되는 부분
- 논의가 필요한 부분
- 잠재적 이슈
```

#### 워크로그 관리 원칙
1. 파일 위치
   - 모든 워크로그는 `worklogs/` 디렉토리에 저장
   - 주제별로 별도의 파일 생성
   - 연관된 작업은 동일한 파일에 추가

2. 실시간 업데이트
   - 작업 진행 상황을 실시간으로 기록
   - 발생한 이슈와 해결 방법 상세히 기록
   - 실행한 명령어와 결과 포함

3. 이슈 추적
   - 모든 이슈는 발생 즉시 기록
   - 해결 방법과 적용 결과 포함
   - 향후 참고를 위한 상세한 설명 추가

4. 명령어 기록
   - 실행한 모든 주요 명령어를 코드 블록으로 기록
   - 명령어의 목적과 결과를 주석으로 설명
   - 환경 설정이나 버전 정보도 함께 기록

5. 문서 품질
   - 명확하고 구조화된 형식 사용
   - 코드 블록과 설명을 적절히 조합
   - 재현 가능한 수준의 상세한 기록 유지

### 1.3 작업 로그 관리 원칙

1. 실시간 업데이트
   - 각 작업 단계를 시작할 때 상태 이모지로 진행 상황 표시
   - 명령어 실행 시 실제 사용된 명령어를 코드 블록으로 기록
   - 발생한 이슈는 즉시 기록하고 해결 과정 추적

2. 이슈 기록
   - 발견된 모든 이슈를 시간 순서대로 기록
   - 각 이슈의 원인과 해결 방법을 상세히 설명
   - 해결된 이슈는 체크 표시하되 기록은 유지

3. 작업 이력 관리
   - 모든 주요 변경사항을 시간 순서대로 기록
   - 각 변경사항의 의도와 결과를 명확히 설명
   - 실패한 시도도 기록하여 향후 참고자료로 활용

4. 명령어 기록
   - 실행한 모든 주요 명령어를 코드 블록으로 기록
   - 명령어의 목적과 결과를 주석으로 설명
   - 환경 설정이나 버전 정보도 함께 기록

5. 상태 관리
   - 작업의 현재 상태를 이모지로 명확히 표시
   - 단계별 진행 상황을 실시간으로 업데이트
   - 차단된 작업이나 대기 중인 작업도 명시

## 2. 작업 실행 프로세스

### 2.1 작업 진행
- 기술 명세에 대한 사용자의 승인을 받은 후 작업 시작
- 명세의 작업 순서대로 진행하며 각 단계 완료 시 결과 보고
- 예상치 못한 문제나 변경사항 발생 시 즉시 보고

### 2.2 결과물 검증
- 명세의 예상 결과물과 비교하여 검증
- 필요시 수정 사항 제안

## 3. PR 생성 프로세스

### 3.1 PR 준비
- 작업 내용을 1~4개의 영어 단어로 요약하여 브랜치명 결정
  - 예: `add-todo-feature`
  - 예: `fix-auth-bug`
  - 예: `update-ui-components`
  - 예: `refactor-api-client`

### 3.2 브랜치 생성 및 커밋
사용자가 "PR 생성"을 요청한 경우 다음 워크플로우로 진행:

1. main 브랜치 최신화 및 새로운 브랜치 생성
   - main 브랜치로 이동 후 원격 저장소에서 최신 변경사항 가져오기 (git checkout main && git pull)
   - 최신 main 브랜치를 기반으로 새로운 브랜치 생성
   - 작업 내용을 대표하는 의미있는 브랜치명 사용

2. 변경사항 커밋
   - 모든 변경사항을 스테이징
   - 작업 내용을 설명하는 커밋 메시지 작성
   - 변경사항 커밋

3. 원격 저장소에 푸시
   - 새로 생성한 브랜치를 원격 저장소에 푸시
   - 푸시 과정에서 문제 발생시 자동 해결 시도

### 3.3 문제 해결 프로세스
gh, git 등 PR 생성 작업을 진행하며 문제가 발생한경우 다음 내용을 고려:
- 자동으로 해결 가능한 일반적인 상황은 즉시 처리
- 사용자 판단이 필요한 경우 상황 설명 후 해결 방안 제시
- 모든 과정에서 작업 내용 보존을 최우선으로 고려

### 3.4 PR 생성 명령어
```bash
gh pr create \
  --title "[작업 유형] 작업 제목" \
  --body "## 작업 개요
- 목적: [작업의 주요 목적]
- 변경사항: [주요 변경 내용]

## 아키텍처 및 설계 결정
- 선택한 아키텍처/패턴: [설명]
- 대안과 비교: [다른 접근 방식들과 비교]
- 선택 이유: [이 방식을 선택한 이유]

## 기술 스택 및 라이브러리
- 사용/추가된 기술: [기술명과 버전]
- 기술 선택 배경: [왜 이 기술을 선택했는지]
- 향후 확장성: [미래 요구사항 대응 방안]

## 성능 및 보안 고려사항
- 성능 영향: [성능에 미치는 영향]
- 잠재적 이슈: [예상되는 문제점]
- 대응 방안: [이슈 해결을 위한 접근 방법]" \
  --assignee "@me"
```

### 3.5 PR 생성 후 처리
- PR 링크를 사용자에게 공유
- PR 상태 모니터링
- 리뷰어 피드백에 대한 대응 준비

## 4. 문제 해결 및 커뮤니케이션

### 4.1 문제 해결 원칙
- 오류 상황 명확히 파악하고 원인 분석
- 해결 방안의 영향도 평가 후 사용자에게 제시
- 환경 설정 문제는 영구적 해결 방안 우선 제시

### 4.2 커뮤니케이션 원칙
- 명확하고 구조화된 형식으로 보고
- 전문 용어 사용 시 설명 추가
- 대안이 있는 경우 장단점과 함께 제시
- 기술적 제안 시 근거와 예상 효과 제시

## 5. 품질 관리

### 5.1 코드 품질 및 결과물 검증
- 코딩 컨벤션 준수
- 성능, 보안, 확장성 고려
- 변경 과정에서 발생하는 이슈는 즉시 보고

### 5.2 코드 수정 원칙
- 최소 변경 원칙 준수
  - 요청된 변경사항에만 집중
  - 불필요한 코드 재작성 지양
  - 기존 코드의 의도와 맥락 유지

- 변경 범위 명확화
  - 수정이 필요한 부분을 명확히 식별
  - 연관된 부분에 미치는 영향 검토
  - 의도하지 않은 변경사항 방지

- 단계별 검증
  1. 변경 전 코드의 기능과 스타일 파악
  2. 최소한의 변경으로 목적 달성
  3. 변경 후 원래 기능과 스타일이 유지되는지 확인

- 리팩토링 시 주의사항
  - 순수 리팩토링과 기능 변경을 분리
  - 리팩토링이 필요한 경우 사용자와 상의
  - UI 변경이 포함된 경우 반드시 스크린샷 비교

### 5.3 변경사항 문서화
- 각 변경사항의 목적과 영향 범위 기록
- 예상치 못한 변경이 발생한 경우 즉시 보고
- 변경 전/후 비교 자료 제공 (필요시 스크린샷 포함)

### 5.4 코드 리뷰 체크리스트
변경사항 적용 전 다음 사항 확인:
- [ ] 요청된 변경사항만 포함되었는가?
- [ ] 기존 기능이 그대로 유지되는가?
- [ ] UI/스타일링이 의도치 않게 변경되지 않았는가?
- [ ] 연관된 테스트가 모두 통과하는가?
- [ ] 성능에 부정적 영향을 주지 않는가?