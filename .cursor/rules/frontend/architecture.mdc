---
description: 프론트엔드 아키텍처 설계 및 개발 가이드라인을 정의합니다
globs: ["frontend/**/*"]
alwaysApply: false
---

# 프로젝트 아키텍처 가이드라인

## 기술 스택

### Frontend
- **프레임워크**: React 18+ (함수형 컴포넌트 + Hooks)
- **언어**: TypeScript 5.0+ (strict 모드)
- **상태 관리**: 
  - 로컬 상태: useState, useReducer
  - 전역 상태: Zustand (가벼운 상태) 또는 Context API (복잡한 상태)
  - 서버 상태: React Query (TanStack Query)
- **라우팅**: React Router v6
- **스타일링**: 
  - Vanilla Extract (타입 안전한 CSS-in-JS)
  - Radix UI (접근성이 보장된 UI 컴포넌트)
- **빌드 도구**: Vite (빠른 개발 환경)
- **패키지 매니저**: Yarn (안정적이고 빠른 의존성 관리)

### 개발 도구
- **코드 포맷터/린터**: Biome (빠르고 일관된 코드 스타일)
- **타입 체크**: TypeScript strict 모드
- **테스팅**: Vitest + React Testing Library + MSW
- **상태 관리 도구**: Zustand DevTools

## 폴더 구조

```
src/
├── features/          # 기능별 모듈화
│   ├── auth/         # 인증 관련 기능
│   │   ├── components/  # 인증 관련 컴포넌트
│   │   ├── hooks/      # 인증 관련 훅
│   │   ├── api/        # 인증 관련 API
│   │   ├── store/      # 인증 관련 상태 관리
│   │   ├── types/      # 인증 관련 타입
│   │   ├── utils/      # 인증 관련 유틸리티
│   │   └── index.ts    # 기능 진입점
│   ├── todos/        # Todo 관련 기능
│   │   ├── components/  # Todo 관련 컴포넌트
│   │   ├── hooks/      # Todo 관련 훅
│   │   ├── api/        # Todo 관련 API
│   │   ├── store/      # Todo 관련 상태 관리
│   │   ├── types/      # Todo 관련 타입
│   │   ├── utils/      # Todo 관련 유틸리티
│   │   └── index.ts    # 기능 진입점
│   └── users/        # 사용자 관련 기능
│       ├── components/  # 사용자 관련 컴포넌트
│       ├── hooks/      # 사용자 관련 훅
│       ├── api/        # 사용자 관련 API
│       ├── store/      # 사용자 관련 상태 관리
│       ├── types/      # 사용자 관련 타입
│       ├── utils/      # 사용자 관련 유틸리티
│       └── index.ts    # 기능 진입점
├── shared/           # 공유 리소스
│   ├── components/   # 공통 컴포넌트 (Button, Input, Modal 등)
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.test.tsx
│   │   │   └── index.ts
│   │   └── index.ts
│   ├── hooks/       # 공통 훅 (useLocalStorage, useDebounce 등)
│   ├── utils/       # 공통 유틸리티 (날짜, 검증 등)
│   └── types/       # 공통 타입 정의
├── app/             # 앱 코어
│   ├── providers/   # 앱 전역 프로바이더
│   ├── routes/      # 라우트 설정
│   └── store/       # 전역 상태 설정
└── assets/          # 정적 자산
    ├── images/
    └── icons/
```

## 코딩 컨벤션

### 네이밍 규칙
- **컴포넌트**: PascalCase (예: `TodoItem`, `UserProfile`)
- **파일명**: kebab-case (예: `todo-item.tsx`, `user-profile.tsx`)
- **함수/변수**: camelCase (예: `getTodoList`, `userName`)
- **상수**: UPPER_SNAKE_CASE (예: `API_BASE_URL`, `MAX_TODO_COUNT`)
- **타입/인터페이스**: PascalCase (예: `TodoItem`, `UserData`)

### 컴포넌트 작성 규칙
```typescript
// todo-item.css.ts
import { style } from '@vanilla-extract/css';

export const todoItemStyles = {
  container: style({
    display: 'flex',
    alignItems: 'center',
    gap: '0.5rem',
    padding: '0.75rem',
    border: '1px solid #e5e7eb',
    borderRadius: '0.375rem',
  }),
  
  checkbox: style({
    width: '1rem',
    height: '1rem',
  }),
  
  text: style({
    flex: 1,
  }),
  
  completedText: style({
    flex: 1,
    textDecoration: 'line-through',
    color: '#9ca3af',
  }),
  
  deleteButton: style({
    marginLeft: 'auto',
    color: '#ef4444',
    ':hover': {
      color: '#dc2626',
    },
  }),
};

// TodoItem.tsx
import { todoItemStyles } from './todo-item.css.ts';

interface TodoItemProps {
  id: string;
  title: string;
  completed: boolean;
  onToggle: (id: string) => void;
  onDelete: (id: string) => void;
}

export const TodoItem: React.FC<TodoItemProps> = ({
  id,
  title,
  completed,
  onToggle,
  onDelete,
}) => {
  return (
    <div className={todoItemStyles.container}>
      <input
        type="checkbox"
        checked={completed}
        onChange={() => onToggle(id)}
        className={todoItemStyles.checkbox}
      />
      <span className={completed ? todoItemStyles.completedText : todoItemStyles.text}>
        {title}
      </span>
      <button
        onClick={() => onDelete(id)}
        className={todoItemStyles.deleteButton}
      >
        삭제
      </button>
    </div>
  );
};
```

### 상태 관리 패턴

#### 로컬 상태 (useState)
```typescript
// 폼 데이터, UI 상태 등
const [isLoading, setIsLoading] = useState(false);
const [formData, setFormData] = useState({ title: '', description: '' });
```

#### 전역 상태 (Zustand)
```typescript
// store/todoStore.ts
interface TodoStore {
  todos: Todo[];
  isLoading: boolean;
  addTodo: (todo: Omit<Todo, 'id'>) => void;
  toggleTodo: (id: string) => void;
  deleteTodo: (id: string) => void;
}

export const useTodoStore = create<TodoStore>((set) => ({
  todos: [],
  isLoading: false,
  addTodo: (todo) => set((state) => ({
    todos: [...state.todos, { ...todo, id: generateId() }]
  })),
  toggleTodo: (id) => set((state) => ({
    todos: state.todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    )
  })),
  deleteTodo: (id) => set((state) => ({
    todos: state.todos.filter(todo => todo.id !== id)
  })),
}));
```

#### 서버 상태 (React Query)
```typescript
// hooks/useTodos.ts
export const useTodos = () => {
  return useQuery({
    queryKey: ['todos'],
    queryFn: todoApi.getTodos,
  });
};

export const useCreateTodo = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: todoApi.createTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    },
  });
};
```

## API 설계 패턴

### API 클라이언트 설정
```typescript
// services/api.ts
import ky from 'ky';

const api = ky.create({
  prefixUrl: process.env.REACT_APP_API_URL || 'http://localhost:3001/api',
  timeout: 10000,
  hooks: {
    beforeRequest: [
      request => {
        const token = localStorage.getItem('token');
        if (token) {
          request.headers.set('Authorization', `Bearer ${token}`);
        }
      }
    ],
    afterResponse: [
      async (request, options, response) => {
        if (response.status === 401) {
          // 인증 실패 처리
          localStorage.removeItem('token');
          window.location.href = '/login';
        }
        return response;
      }
    ]
  }
});

export default api;
```

### API 서비스 함수
```typescript
// features/todos/api/todoApi.ts
import { api } from '@/shared/api';
import type { Todo, CreateTodoRequest } from '../types';

export const todoApi = {
  getTodos: async (): Promise<Todo[]> => {
    return api.get('todos').json();
  },
  
  createTodo: async (data: CreateTodoRequest): Promise<Todo> => {
    return api.post('todos', {
      json: data
    }).json();
  },
  
  updateTodo: async (id: string, data: Partial<Todo>): Promise<Todo> => {
    return api.put(`todos/${id}`, {
      json: data
    }).json();
  },
  
  deleteTodo: async (id: string): Promise<void> => {
    await api.delete(`todos/${id}`);
  },
};
```

### 에러 처리
```typescript
// shared/api/error.ts
export class ApiError extends Error {
  constructor(
    public status: number,
    public statusText: string,
    public data: any
  ) {
    super(`${status} ${statusText}`);
    this.name = 'ApiError';
  }
}

// API 에러 처리 훅
export const useApiMutation = <TData, TVariables>(
  mutationFn: (variables: TVariables) => Promise<TData>,
  options?: {
    onSuccess?: (data: TData) => void;
    onError?: (error: ApiError) => void;
  }
) => {
  return useMutation({
    mutationFn: async (variables: TVariables) => {
      try {
        return await mutationFn(variables);
      } catch (error) {
        if (error instanceof Response) {
          const data = await error.json();
          throw new ApiError(error.status, error.statusText, data);
        }
        throw error;
      }
    },
    ...options
  });
};
```

### 사용 예시
```typescript
// features/todos/components/TodoList.tsx
export const TodoList = () => {
  const { data: todos, error } = useQuery({
    queryKey: ['todos'],
    queryFn: todoApi.getTodos
  });

  const createTodo = useApiMutation(todoApi.createTodo, {
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
      toast.success('할 일이 추가되었습니다.');
    },
    onError: (error) => {
      toast.error(`할 일 추가 실패: ${error.message}`);
    }
  });

  // ... 나머지 컴포넌트 로직
};
```

## 타입 정의 패턴

### 기본 타입
```typescript
// types/todo.ts
export interface Todo {
  id: string;
  title: string;
  description?: string;
  completed: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateTodoRequest {
  title: string;
  description?: string;
}

export interface UpdateTodoRequest {
  title?: string;
  description?: string;
  completed?: boolean;
}

// types/api.ts
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
}

export interface ApiError {
  success: false;
  error: {
    code: string;
    message: string;
  };
}
```

## 스타일링 가이드라인

### Vanilla Extract 사용법
```typescript
// button.css.ts
import { style, styleVariants } from '@vanilla-extract/css';

const baseButton = style({
  padding: '0.5rem 1rem',
  borderRadius: '0.375rem',
  fontWeight: 500,
  transition: 'all 0.2s',
});

export const buttonVariants = styleVariants({
  primary: [baseButton, {
    backgroundColor: '#3b82f6',
    color: 'white',
    ':hover': {
      backgroundColor: '#2563eb',
    },
  }],
  secondary: [baseButton, {
    backgroundColor: '#e5e7eb',
    color: '#1f2937',
    ':hover': {
      backgroundColor: '#d1d5db',
    },
  }],
  danger: [baseButton, {
    backgroundColor: '#ef4444',
    color: 'white',
    ':hover': {
      backgroundColor: '#dc2626',
    },
  }],
});

// Button.tsx
import { buttonVariants } from './button.css.ts';

export const Button: React.FC<ButtonProps> = ({ variant = 'primary', children, ...props }) => {
  return (
    <button
      className={buttonVariants[variant]}
      {...props}
    >
      {children}
    </button>
  );
};
```

### Radix UI 사용법
```typescript
import * as Dialog from '@radix-ui/react-dialog';
import { styled } from '@vanilla-extract/css';

const StyledOverlay = styled(Dialog.Overlay, {
  backgroundColor: 'rgba(0, 0, 0, 0.5)',
  position: 'fixed',
  inset: 0,
});

const StyledContent = styled(Dialog.Content, {
  backgroundColor: 'white',
  borderRadius: '6px',
  padding: '20px',
  position: 'fixed',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
});

export const Modal = ({ isOpen, onClose, children }) => (
  <Dialog.Root open={isOpen} onOpenChange={onClose}>
    <Dialog.Portal>
      <StyledOverlay />
      <StyledContent>
        {children}
      </StyledContent>
    </Dialog.Portal>
  </Dialog.Root>
);
```

## 테스트 전략

### 컴포넌트 테스트
```typescript
// components/common/Button/Button.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByText('Click me')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByText('Click me'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### 커스텀 훅 테스트
```typescript
// hooks/useLocalStorage.test.ts
import { describe, it, expect, beforeEach } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { useLocalStorage } from './useLocalStorage';

describe('useLocalStorage', () => {
  beforeEach(() => {
    localStorage.clear();
  });

  it('returns initial value when no stored value', () => {
    const { result } = renderHook(() => useLocalStorage('test', 'default'));
    expect(result.current[0]).toBe('default');
  });

  it('updates stored value', () => {
    const { result } = renderHook(() => useLocalStorage('test', 'default'));
    
    act(() => {
      result.current[1]('new value');
    });
    
    expect(result.current[0]).toBe('new value');
    expect(localStorage.getItem('test')).toBe('"new value"');
  });
});
```

## 성능 최적화

### 메모이제이션
```typescript
// ✅ 좋은 예시 - React.memo 사용
export const TodoItem = React.memo<TodoItemProps>(({ todo, onToggle, onDelete }) => {
  return (
    <div className="todo-item">
      {/* 컴포넌트 내용 */}
    </div>
  );
});

// ✅ 좋은 예시 - useMemo 사용
const expensiveValue = useMemo(() => {
  return todos.filter(todo => todo.completed).length;
}, [todos]);

// ✅ 좋은 예시 - useCallback 사용
const handleToggle = useCallback((id: string) => {
  onToggle(id);
}, [onToggle]);
```

### 코드 스플리팅
```typescript
// pages/TodoList.tsx
const TodoList = lazy(() => import('./TodoList'));

// App.tsx
<Suspense fallback={<div>Loading...</div>}>
  <TodoList />
</Suspense>
```

## 에러 처리

### 에러 바운더리
```typescript
// components/ErrorBoundary.tsx
class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }

    return this.props.children;
  }
}
```

### API 에러 처리
```typescript
// hooks/useApi.ts
export const useApi = <T>(queryFn: () => Promise<T>) => {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<Error | null>(null);
  const [isLoading, setIsLoading] = useState(false);

  const execute = useCallback(async () => {
    try {
      setIsLoading(true);
      setError(null);
      const result = await queryFn();
      setData(result);
    } catch (err) {
      setError(err as Error);
    } finally {
      setIsLoading(false);
    }
  }, [queryFn]);

  return { data, error, isLoading, execute };
};
```

## 개발 환경 설정

### 환경 변수
```bash
# .env.local
REACT_APP_API_URL=http://localhost:3001/api
REACT_APP_ENV=development
```

### 패키지 스크립트
```json
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:watch": "vitest watch",
    "test:coverage": "vitest run --coverage",
    "format": "biome format ./src",
    "format:fix": "biome format --write ./src",
    "lint": "biome check ./src",
    "lint:fix": "biome check --apply ./src",
    "type-check": "tsc --noEmit"
  }
}
```

이 가이드라인을 따라 개발하면 일관성 있고 유지보수하기 쉬운 코드를 작성할 수 있습니다.

- 단위 테스트: Vitest + React Testing Library
- 컴포넌트 테스트 우선
- 커스텀 훅 테스트 포함

